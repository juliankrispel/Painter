// Generated by CoffeeScript 1.6.3
(function() {
  var PI, cumulativeOffset, getAngleBetweenVectors, getCenterPoint, getDotProduct, getVectorLength, getVectorOrientation, matrixToCss, prefixes, radiansToDegrees, template, transformCoordinates, transformImage, transformMatrix;

  PI = Math.PI;

  radiansToDegrees = function(radians) {
    return radians * (180 / Math.PI);
  };

  cumulativeOffset = function(element) {
    var left, top;
    top = 0;
    left = 0;
    while (element) {
      top += element.offsetTop || 0;
      left += element.offsetLeft || 0;
      element = element.offsetParent;
    }
    return {
      top: top,
      left: left
    };
  };

  template = '<div data-type="translate" class="transformation-handle__translate"></div>\
  <div class="anchorpoint"></div>\
  <div data-type="rotate" class="transformation-handle transformation-handle__top-left tranformation-handle__rotate"><div data-type="scale" class="transformation-handle__scale"></div></div>\
  <div data-type="rotate" class="transformation-handle transformation-handle__top-right transformation-handle__rotate"><div data-type="scale" class="transformation-handle__scale"></div></div>\
  <div data-type="rotate" class="transformation-handle transformation-handle__bottom-left transformation-handle__rotate"><div data-type="scale" class="transformation-handle__scale"></div></div>\
  <div data-type="rotate" class="transformation-handle transformation-handle__bottom-right transformation-handle__rotate"><div data-type="scale" class="transformation-handle__scale"></div></div>';

  transformImage = function(el, obj) {
    var css, i, string, transformString, x, _results;
    css = "";
    string = "";
    for (x in obj) {
      transformString = obj[x].join(",");
      string += x + "(" + transformString + ")";
    }
    _results = [];
    for (i in prefixes) {
      _results.push(el.style.setProperty(prefixes[i] + "transform", string, "important"));
    }
    return _results;
  };

  getDotProduct = function(a, b) {
    var i, lim, n;
    n = 0;
    lim = Math.min(a.length, b.length);
    i = 0;
    while (i < lim) {
      n += a[i] * b[i];
      i++;
    }
    return n;
  };

  getVectorLength = function(v) {
    var i, sum;
    sum = 0;
    i = 0;
    while (i < v.length) {
      sum += v[i] * v[i];
      i++;
    }
    return Math.sqrt(sum);
  };

  matrixToCss = function(m) {
    return [m[0], m[3], m[1], m[4], m[2], m[5]];
  };

  transformMatrix = function(t) {
    return t['translate'].multMat(t['rotate'].multMat(t['scale']));
  };

  transformCoordinates = function(coord, matrix) {
    var v;
    v = [coord[0], coord[1], 1];
    return matrix.multVec(v);
  };

  getCenterPoint = function(tValues, width, height) {
    return [(tValues['scale'][0] * width / 2) + tValues['translate'][0], (tValues['scale'][1] * height / 2) + tValues['translate'][1]];
  };

  getAngleBetweenVectors = function(a, b) {
    return Math.acos(getDotProduct(a, b) / (getVectorLength(a) * getVectorLength(b)));
  };

  getVectorOrientation = function(a, b, c) {
    var direction;
    direction = (a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]);
    if (direction > 0) {
      return -1;
    } else if (direction < 0) {
      return 1;
    } else if (direction === 0) {
      return 0;
    } else {
      throw new Error("");
    }
  };

  prefixes = ["-moz-", "-webkit-", "-ms-", "-khtml-", "-o-", ""];

  xtag.register("x-painter-transform", {
    lifecycle: {
      created: function() {
        var height, width;
        this.mousedown = false;
        this.container = document.createElement('div');
        this.container.className = 'transformation-container';
        this.container.innerHTML = this.innerHTML;
        this.innerHTML = template;
        this.appendChild(this.container);
        this.handles = {
          'transformation-handle__top-left': [0, 0],
          'transformation-handle__top-right': [this.container.offsetWidth, 0],
          'transformation-handle__bottom-right': [this.container.offsetWidth, this.container.offsetHeight],
          'transformation-handle__bottom-left': [0, this.container.offsetHeight]
        };
        this.t = {
          'rotate': new Mat3,
          'scale': new Mat3,
          'translate': new Mat3
        };
        this.tValues = {
          rotate: 0,
          scale: [1, 1],
          translate: [0, 0]
        };
        this.data - (width = this.container.offsetWidth);
        this.data - (height = this.container.offsetHeight);
        this.anchorPoint = getCenterPoint(this.tValues, this.data - width, this.data - height);
        this.querySelector('.anchorpoint').style.setProperty('left', this.anchorPoint[0]);
        this.querySelector('.anchorpoint').style.setProperty('top', this.anchorPoint[1]);
        return window.el = this;
      }
    },
    methods: {
      transform: function() {
        var bbox, coord, css, handle, matrix, prefix, _i, _len, _results;
        bbox = this.container.getBoundingClientRect();
        this.anchorPoint = [bbox.left + bbox.width / 2, bbox.top + bbox.height / 2];
        console.log(bbox);
        this.querySelector('.anchorpoint').style.setProperty('left', this.anchorPoint[0]);
        this.querySelector('.anchorpoint').style.setProperty('top', this.anchorPoint[1]);
        matrix = transformMatrix(this.t);
        css = "matrix(" + (matrixToCss(matrix._m)) + ")";
        for (handle in this.handles) {
          coord = transformCoordinates(this.handles[handle], matrix);
          this.querySelector("." + handle).style.setProperty('left', coord[0]);
          this.querySelector("." + handle).style.setProperty('top', coord[1]);
        }
        this.container.style.setProperty('background-color', 'red');
        _results = [];
        for (_i = 0, _len = prefixes.length; _i < _len; _i++) {
          prefix = prefixes[_i];
          _results.push(this.container.style.setProperty("" + prefix + "transform", css));
        }
        return _results;
      },
      processMouseMovement: function(type, startX, startY, endX, endY, anchorX, anchorY, isShiftPressed) {
        var a, angle, b, c, direction, origin, sx, sy, vektorA, vektorB;
        switch (type) {
          case 'scale':
            origin = this.anchorPoint;
            a = [startX - origin[0], startY - origin[1]];
            b = [endX - origin[0], endY - origin[1]];
            sx = (endX - origin[0]) / (startX - origin[0]);
            sy = (endY - origin[1]) / (startY - origin[1]);
            if (isShiftPressed) {
              if (sx && sy > 1) {
                if (sx > sy) {
                  sy = sx;
                } else {
                  sx = sy;
                }
              } else {
                if (sx < sy) {
                  sy = sx;
                } else {
                  sx = sy;
                }
              }
            }
            return this.scaleEl(sx, sy);
          case 'rotate':
            a = [anchorX, anchorY];
            b = [startX, startY];
            c = [endX, endY];
            direction = getVectorOrientation(a, b, c);
            vektorA = [b[0] - a[0], b[1] - a[1]];
            vektorB = [c[0] - a[0], c[1] - a[1]];
            angle = radiansToDegrees(getAngleBetweenVectors(vektorA, vektorB));
            return this.rotateEl(direction * angle);
          case 'translate':
            return this.translateEl(endX - startX, endY - startY);
        }
      },
      translateEl: function(x, y) {
        this.t['translate'] = this.t['translate'].translate(x, y);
        return this.transform();
      },
      scaleEl: function(sx, sy) {
        var m;
        this.tValues['scale'][0] += sx;
        this.tValues['scale'][1] += sy;
        m = new Mat3;
        this.t['scale'] = m.scale(this.anchorPoint, this.anchorPoint, this.tValues['scale'][0], this.tValues['scale'][1]);
        return this.transform();
      },
      rotateEl: function(angle, px, py) {
        px = this.anchorPoint[0];
        py = this.anchorPoint[1];
        this.t['rotate'] = this.t['rotate'].rotate(px, py, angle);
        return this.transform();
      }
    },
    events: {
      'mousedown': function(e) {
        if (e.srcElement.dataset.type) {
          return this.mousedown = {
            type: e.srcElement.dataset.type,
            x: e.x,
            y: e.y
          };
        }
      },
      'mousemove': function(e) {
        if (this.mousedown) {
          this.processMouseMovement(this.mousedown.type, this.mousedown.x, this.mousedown.y, e.x, e.y, this.anchorPoint[0], this.anchorPoint[1], e.shiftKey);
          this.mousedown.x = e.x;
          return this.mousedown.y = e.y;
        }
      },
      'mouseup': function(e) {
        return this.mousedown = false;
      }
    }
  });

}).call(this);
